extern crate num;

use num::bigint::BigInt;
use num::{Zero, One};
use num::ToPrimitive;

use std::ops::{Add, Sub, Mul, Div, Rem, Neg};
use std::cmp::Ordering;
use std::hash::Hash;
use std::convert::From;
use std::collections::HashMap;
use std::io::{self, Write};


/// Find the standard representation of a (mod n).
fn normalize<T: Integer>(a: T, n: &T) -> T
    where for<'a> &'a T: IntegerOps<T>
{
    let a = a % n;
    match a.cmp(&T::zero()) {
        Ordering::Less => a + n,
        _ => a,
    }
}

#[derive(Debug, Copy, Clone, PartialEq, Eq)]
struct GcdResult<T> {
    /// Greatest common divisor.
    gcd: T,
    /// Coefficients such that: gcd(a, b) = c1*a + c2*b
    c1: T, c2: T,
}

/// Calculate greatest common divisor and the corresponding coefficients.
fn extended_gcd<T: Integer>(a: T, b: T) -> GcdResult<T>
    where for<'a> &'a T: IntegerOps<T>
{
    // Euclid's extended algorithm
    let (mut s, mut old_s) = (T::zero(), T::one());
    let (mut t, mut old_t) = (T::one(), T::zero());
    let (mut r, mut old_r) = (b, a);

    while r != T::zero() {
        let quotient = &old_r / &r;
        old_r = old_r - &quotient * &r; std::mem::swap(&mut old_r, &mut r);
        old_s = old_s - &quotient * &s; std::mem::swap(&mut old_s, &mut s);
        old_t = old_t - quotient * &t; std::mem::swap(&mut old_t, &mut t);
    }

    let _quotients = (t, s); // == (a, b) / gcd

    GcdResult { gcd: old_r, c1: old_s, c2: old_t }
}

/// Calculate the inverse of a (mod n).
fn inverse<T: Integer + Clone>(a: T, n: &T) -> Option<T>
    where for<'a> &'a T: IntegerOps<T>
{
    let GcdResult { gcd, c1: c, .. } = extended_gcd(a, n.clone());
    if gcd == T::one() {
        Some(normalize(c, n))
    } else {
        None
    }
}

/// Calculate base^exp (mod modulus).
fn powm(base: &BigInt, exp: &BigInt, modulus: &BigInt) -> BigInt {
    let zero = Integer::zero();
    let one: BigInt = Integer::one();
    let two = &one + &one;
    let mut exp = exp.clone();
    let mut result = one.clone();
    let mut base = base % modulus;
    if exp < zero {
        exp = -exp;
        base = inverse(base, modulus).unwrap();
    }
    while exp > zero {
        if &exp % &two == one {
            result = (result * &base) % modulus;
        }
        exp = exp >> 1;
        base = (&base * &base) % modulus;
    }
    result
}

trait IntegerValOps<RHS, Output>: Sized
+ Add<RHS, Output = Output> + Sub<RHS, Output = Output>
+ Mul<RHS, Output = Output> + Div<RHS, Output = Output>
+ Rem<RHS, Output = Output> + Neg<Output = Output> {
}

impl<RHS, Output, T> IntegerValOps<RHS, Output> for T
    where T: Sized
    + Add<RHS, Output = Output> + Sub<RHS, Output = Output>
    + Mul<RHS, Output = Output> + Div<RHS, Output = Output>
    + Rem<RHS, Output = Output> + Neg<Output = Output>
{
}

trait IntegerOps<Base>: IntegerValOps<Base, Base>
+ for<'a> IntegerValOps<&'a Base, Base> {
}

impl<Base, T> IntegerOps<Base> for T
    where T: IntegerValOps<Base, Base>
    + for<'a> IntegerValOps<&'a Base, Base>
{
}

trait Integer:
Sized + Eq + Ord + Clone
+ IntegerOps<Self>
+ From<u64> + Hash
{
    fn zero() -> Self;
    fn one() -> Self;
    fn invert(&self, modulus: &Self) -> Option<Self>;
    fn powm(&self, exp: &Self, modulus: &Self) -> Self;
}

impl Integer for BigInt {
    fn zero() -> BigInt {
        Zero::zero()
    }

    fn one() -> BigInt {
        One::one()
    }

    fn invert(&self, modulus: &BigInt) -> Option<BigInt> {
        inverse(self.clone(), modulus)
    }

    fn powm(&self, exp: &BigInt, modulus: &BigInt) -> BigInt {
        powm(self, exp, modulus)
    }
}

/// Calculate `x` where `g**x = h (mod p)`.
/// `x` has to be smaller than `2**x_max_exp`.
fn discrete_log<'a, T>(g: &T, h: &'a T, p: &'a T, x_max_exp: usize) -> usize
    where &'a T: Rem,
          T: Integer + From<<&'a T as Rem>::Output>,
{
    let B: usize = 1 << (x_max_exp / 2);
    let b = T::from(B as u64);

    // Build table.
    let mut table: HashMap<T, usize> = HashMap::with_capacity(B);
    let g_inv = g.invert(p).unwrap();
    let mut lhs = T::from(h % p);
    for x1 in 0..B {
        if x1 > 0 {
            lhs = (lhs * &g_inv) % p;
        }
        table.insert(lhs.clone(), x1);
    }

    // Find collision.
    let g_b = g.powm(&b, p);
    let mut rhs = T::one();
    for x0 in 0..B {
        if x0 > 0 {
            rhs = (rhs * &g_b) % p;
        }

        if let Some(&x1) = table.get(&rhs) {
            return x0 * B + x1;
        }
    }
    panic!("`x_max_exp` is too small");
}

fn solve<T : Into<BigInt>>(x: T, y: T, z: T) -> u64 {
    let g = x.into();
    let a = y.into();
    let m = z.into();

    let exp = ((m.to_i64().unwrap() as f64).log2().ceil()) as usize + 1;
    // println!("{} {}", exp, m.to_i64().unwrap());
    discrete_log(&g, &a, &m, exp).to_u64().unwrap()
}


fn main() {
    let gk: [i64; 52] = [494, 591, 354, 667, 865, 743, 83, 835, 403, 511, 972, 718, 759, 487, 353, 194, 647, 824, 155, 623, 608, 149, 26, 596, 197, 955, 570, 709, 245, 867, 347, 953, 191, 268, 442, 249, 610, 486, 525, 834, 985, 353, 443, 840, 889, 606, 31, 459, 220, 695, 725, 258];
    let mk: [i64; 52] = [1918933, 3541871, 5367191, 8177207, 13413287, 8617753, 16482799, 637997546888497, 818030409780821, 1072039080450269, 1004843678320291, 1115141712472331, 1032376426518289, 958985624325359, 897355104115111, 909207636223351, 634950234842603, 1003636421258407, 1028279453914123, 750811524770693, 1041548821164679, 1015423398447347, 568993585251031, 703015189715341, 651039963438941, 1069266826561771, 628638171343969, 701926403641759, 865453089922907, 723838699860821, 730168297437521, 1111613955551009, 872447864446181, 789580776249227, 777112842082561, 716583208032199, 1099783476197993, 761365527314143, 874553915164663, 915155875093297, 771585006089413, 681080227610077, 648352830330449, 1085848716264937, 609570843233567, 578884069993919, 1037573374947757, 982522517944993, 725437567343773, 966920862085537, 866304179096309, 680519947090931];
    let ak: [i64; 52] = [1371117, 408838, 3920830, 7651117, 10637176, 3602396, 10645798, 138964171179166, 606750748470309, 433297185255245, 535265751317005, 178887405705973, 68704404861302, 41218827533975, 790184100777584, 365012727579282, 473880795844838, 1000055220646686, 742583407426601, 83508410161641, 104343564123378, 113614349667489, 466121620528209, 244113664297969, 646088926575929, 1003313594331878, 561265488149581, 359861655099164, 584051089999537, 50561456067072, 214533397325412, 335580653911014, 419549544816335, 566901804363201, 37662275177128, 410928244600321, 156651290007267, 642036029629601, 251823831380283, 552833273943688, 395675845359024, 6865363707243, 572982777642385, 234552073605133, 571434706046575, 158710732978719, 528910011968719, 122798040996377, 507860628377377, 259514572282796, 850467288348361, 77506961958359];
    for i in 0..gk.len() {
        print!("{}", solve(gk[i], ak[i], mk[i]).to_le_bytes()[0] as char);
        io::stdout().flush().unwrap();
    }
    // println!("{}", solve(804i64,486179074550223i64, 750763676114761i64));
    let mut input = String::new();
    let _string = std::io::stdin().read_line(&mut input).ok().expect("Failed to read line");
}
